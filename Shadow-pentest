import asyncio
import random
import string
import socket
import json
import requests
from aiohttp import ClientSession, ClientTimeout
from prettytable import PrettyTable
from pyfiglet import Figlet
import dns.resolver
import whois
import logging
import itertools
from urllib.parse import urlparse
from concurrent.futures import ThreadPoolExecutor
import re  # URL doğrulama için ekledik

# Renkli yazı için ANSI escape kodları
class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# Loglama
logging.basicConfig(filename='scan.log', level=logging.INFO)

def log_message(message):
    logging.info(message)

def print_header(title):
    f = Figlet(font='slant')
    header = f.renderText(title)
    print(f"\n{Colors.HEADER}{header}{Colors.ENDC}")

def get_random_user_agent():
    USER_AGENTS = [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Firefox/90.0',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0'
    ]
    return random.choice(USER_AGENTS)

async def make_request(url, headers=None, params=None, timeout=10):
    timeout = ClientTimeout(total=timeout)
    async with ClientSession() as session:
        try:
            async with session.get(url, headers=headers, params=params, timeout=timeout) as response:
                text = await response.text()
                return response.status, text, response.headers
        except asyncio.TimeoutError:
            print(f"{Colors.FAIL}Request to {url} timed out.{Colors.ENDC}")
            return None, None, None
        except Exception as e:
            print(f"{Colors.FAIL}Error occurred: {e}{Colors.ENDC}")
            return None, None, None

async def parallel_requests(urls, headers=None):
    tasks = [make_request(url, headers=headers) for url in urls]
    responses = await asyncio.gather(*tasks)
    return responses

async def check_security_headers(url, user_agent=None):
    headers = {'User-Agent': user_agent or get_random_user_agent()}
    status, _, response_headers = await make_request(url, headers=headers)
    if status is None:
        return

    security_headers = {
        'Content-Security-Policy': 'Web sayfası içeriğini korur.',
        'Strict-Transport-Security': 'HTTPS kullanımını zorunlu kılar.',
        'X-Content-Type-Options': 'MIME türlerinin doğru şekilde belirlenmesini sağlar.',
        'X-Frame-Options': 'Sayfanın başka bir sayfa içinde iframe olarak yüklenmesini engeller.',
        'X-XSS-Protection': 'Tarayıcı bazlı XSS korumasını etkinleştirir.',
        'Referrer-Policy': 'Referrer bilgilerini kontrol eder.',
        'Feature-Policy': 'Tarayıcı özelliklerini kontrol eder.',
        'Access-Control-Allow-Origin': 'CORS politikalarını belirler.'
    }
    
    table = PrettyTable()
    table.field_names = ["Header", "Status", "Explanation"]
    
    for header, explanation in security_headers.items():
        status = response_headers.get(header, "Not Found")
        color = Colors.OKGREEN if status != "Not Found" else Colors.FAIL
        table.add_row([header, f"{color}{status}{Colors.ENDC}", explanation])
    
    print_header("Güvenlik Başlıkları Kontrolü")
    print(table)

async def test_sql_injection(url, user_agent=None):
    payloads = ["' OR '1'='1", '" OR "1"="1', "' OR 1=1 --"]
    results = []
    
    for payload in payloads:
        test_url = f"{url}?search={payload}"
        headers = {'User-Agent': user_agent or get_random_user_agent()}
        status, text, _ = await make_request(test_url, headers=headers)
        
        if status and ("error" in text.lower() or "mysql" in text.lower()):
            results.append(test_url)
    
    print_header("SQL Enjeksiyonu Testi")
    if results:
        table = PrettyTable()
        table.field_names = ["Potential SQL Injection"]
        for result in results:
            table.add_row([f"{Colors.FAIL}{result}{Colors.ENDC}"])
            log_message(f"Potential SQL Injection: {result}")
        print(table)
    else:
        print(f"{Colors.OKGREEN}SQL enjeksiyonu açığı bulunamadı.{Colors.ENDC}")

async def test_xss(url, user_agent=None):
    payloads = ["<script>alert('XSS')</script>", "<img src='x' onerror='alert(1)'>"]
    results = []
    
    for payload in payloads:
        test_url = f"{url}?search={payload}"
        headers = {'User-Agent': user_agent or get_random_user_agent()}
        status, text, _ = await make_request(test_url, headers=headers)
        
        if status and payload in text:
            results.append(test_url)
    
    print_header("XSS Testi")
    if results:
        table = PrettyTable()
        table.field_names = ["Potential XSS Vulnerability"]
        for result in results:
            table.add_row([f"{Colors.FAIL}{result}{Colors.ENDC}"])
            log_message(f"Potential XSS Vulnerability: {result}")
        print(table)
    else:
        print(f"{Colors.OKGREEN}XSS açığı bulunamadı.{Colors.ENDC}")

async def test_command_injection(url, user_agent=None):
    payloads = ["; ls", "| ls", "`ls`"]
    results = []

    for payload in payloads:
        test_url = f"{url}?cmd={payload}"
        headers = {'User-Agent': user_agent or get_random_user_agent()}
        status, text, _ = await make_request(test_url, headers=headers)

        if status and any(cmd in text.lower() for cmd in ["ls", "dir"]):
            results.append(test_url)

    print_header("Injection Testi")
    if results:
        table = PrettyTable()
        table.field_names = ["Potential Command Injection"]
        for result in results:
            table.add_row([f"{Colors.FAIL}{result}{Colors.ENDC}"])
            log_message(f"Potential Command Injection: {result}")
        print(table)
    else:
        print(f"{Colors.OKGREEN}Komut enjeksiyonu açığı bulunamadı.{Colors.ENDC}")

async def test_ssrf(url, user_agent=None):
    payloads = ["http://localhost:8080", "http://169.254.169.254/latest/meta-data/"]
    results = []

    for payload in payloads:
        test_url = f"{url}?target={payload}"
        headers = {'User-Agent': user_agent or get_random_user_agent()}
        status, text, _ = await make_request(test_url, headers=headers)

        if status and "data" in text.lower():
            results.append(test_url)

    print_header("SSRF Testi")
    if results:
        table = PrettyTable()
        table.field_names = ["Potential SSRF Vulnerability"]
        for result in results:
            table.add_row([f"{Colors.FAIL}{result}{Colors.ENDC}"])
            log_message(f"Potential SSRF Vulnerability: {result}")
        print(table)
    else:
        print(f"{Colors.OKGREEN}SSRF açığı bulunamadı.{Colors.ENDC}")

async def check_sensitive_information(url, user_agent=None):
    headers = {'User-Agent': user_agent or get_random_user_agent()}
    status, text, _ = await make_request(url, headers=headers)
    if status is None:
        return

    sensitive_keywords = ["password", "secret", "apikey", "token", "credentials", "passwd", "login"]
    found_keywords = [keyword for keyword in sensitive_keywords if keyword in text.lower()]
    
    print_header("Hassas Bilgi Kontrolü")
    table = PrettyTable()
    table.field_names = ["Hassas Bilgi"]
    if found_keywords:
        table.add_row([f"{Colors.WARNING}{', '.join(found_keywords)}{Colors.ENDC}"])
        log_message(f"Hassas bilgi bulundu: {', '.join(found_keywords)}")
    else:
        table.add_row(["Hassas bilgi bulunamadı."])
    print(table)

async def directory_scan(url, wordlist, user_agent=None):
    results = []
    
    for directory in wordlist:
        test_url = f"{url.rstrip('/')}/{directory.lstrip('/')}"
        headers = {'User-Agent': user_agent or get_random_user_agent()}
        status, _, _ = await make_request(test_url, headers=headers)
        
        if status:
            if status == 200:
                results.append((test_url, "200 OK"))
            elif status == 403:
                results.append((test_url, "403 Forbidden"))

    print_header("Dizin Tarama")
    table = PrettyTable()
    table.field_names = ["URL", "Status"]
    for url, status in results:
        color = Colors.OKGREEN if status == "200 OK" else Colors.WARNING
        table.add_row([f"{color}{url}{Colors.ENDC}", f"{color}{status}{Colors.ENDC}"])
    
    print(table)

async def dns_lookup(domain):
    def resolve_dns(record_type):
        try:
            answers = dns.resolver.resolve(domain, record_type)
            return [answer.to_text() for answer in answers]
        except dns.resolver.NoAnswer:
            return []
        except dns.resolver.NXDOMAIN:
            print(f"{Colors.FAIL}Domain bulunamadı: {domain}{Colors.ENDC}")
            return []
        except Exception as e:
            print(f"{Colors.FAIL}DNS sorgusu başarısız ({record_type}): {e}{Colors.ENDC}")
            return []

    print_header("DNS Lookup")

    # Farklı DNS kaynak türleri için sorgular yapıyoruz
    records = {
        'A': resolve_dns('A'),
        'AAAA': resolve_dns('AAAA'),
        'MX': resolve_dns('MX'),
        'CNAME': resolve_dns('CNAME'),
        'TXT': resolve_dns('TXT'),
        'NS': resolve_dns('NS'),
        'SOA': resolve_dns('SOA'),
        'PTR': resolve_dns('PTR')
    }

    # Sonuçları yazdırıyoruz
    table = PrettyTable()
    table.field_names = ["Record Type", "Record"]
    
    for record_type, entries in records.items():
        if entries:
            for entry in entries:
                table.add_row([record_type, f"{Colors.OKBLUE}{entry}{Colors.ENDC}"])
        else:
            table.add_row([record_type, f"{Colors.OKGREEN}Bulunamadı{Colors.ENDC}"])
    
    print(table)

async def whois_lookup(domain):
    try:
        info = whois.whois(domain)
        return info
    except Exception as e:
        print(f"{Colors.FAIL}WHOIS sorgusu başarısız: {e}{Colors.ENDC}")
        return None

def display_whois_info(info):
    if info:
        print_header("WHOIS Bilgileri")
        table = PrettyTable()
        table.field_names = ["Alan Adı", "Bilgi"]
        for key, value in info.items():
            if value:
                table.add_row([key, value])
        print(table)
    else:
        print(f"{Colors.FAIL}WHOIS bilgisi alınamadı.{Colors.ENDC}")

async def scan_potential_open_ports(target):
    def scan_port(host, port):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(1)
                s.connect((host, port))
                return True
        except Exception:
            return False

    print_header("Potansiyel Açık Port Tarama")
    host = target
    potential_ports = [22, 80, 443, 3306, 5432, 6379, 27017]  # Yaygın açık portlar
    open_ports = []

    # Aynı anda çok sayıda portu tarayabilmek için ThreadPoolExecutor kullanıyoruz
    with ThreadPoolExecutor(max_workers=10) as executor:
        loop = asyncio.get_event_loop()
        futures = [loop.run_in_executor(executor, scan_port, host, port) for port in potential_ports]
        results = await asyncio.gather(*futures)

    table = PrettyTable()
    table.field_names = ["Port", "Status"]
    for port, is_open in zip(potential_ports, results):
        status = "açık" if is_open else "kapalı"
        color = Colors.OKGREEN if is_open else Colors.FAIL
        table.add_row([f"{color}{port}{Colors.ENDC}", f"{color}{status}{Colors.ENDC}"])

    print(table)
    if not any(results):
        print(f"{Colors.OKGREEN}Potansiyel açık port bulunamadı.{Colors.ENDC}")

def generate_wordlist(base_words):
    wordlist = set(base_words)
    for word1, word2 in itertools.product(base_words, repeat=2):
        wordlist.add(f"{word1}/{word2}")
    return list(wordlist)

def is_valid_url(url):
    # URL geçerli bir HTTP veya HTTPS URL'si olup olmadığını kontrol eder
    regex = re.compile(
        r'^(?:http://|https://)'  # Protokol
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}|[A-Z0-9-]{2,})|'  # Alan adı
        r'localhost|'  # Yerel host
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|'  # IP adresi
        r'\[?[A-F0-9]*:[A-F0-9:]+\]?)'  # IPv6 adresi
        r'(?::\d+)?'  # Port numarası
        r'(?:[/?#]\S*)?$'  # Yolu, sorgu veya parantezler
        , re.IGNORECASE)
    return re.match(regex, url) is not None

async def main():
    url = input("Hedef URL girin (http/https): ").strip()

    if not is_valid_url(url):
        print(f"{Colors.FAIL}Geçerli bir URL giriniz.{Colors.ENDC}")
        return

    if not url.startswith('http://') and not url.startswith('https://'):
        url = 'http://' + url

    print_header("Shadow-Pentest")

    user_agent = get_random_user_agent()

    await check_security_headers(url, user_agent)
    await test_sql_injection(url, user_agent)
    await test_xss(url, user_agent)
    await test_command_injection(url, user_agent)
    await test_ssrf(url, user_agent)
    await check_sensitive_information(url, user_agent)

    base_words = ["admin", "login", "dashboard", "user", "files", "data"]
    wordlist = generate_wordlist(base_words)
    await directory_scan(url, wordlist, user_agent)

    domain = urlparse(url).netloc
    await dns_lookup(domain)

    whois_info = await whois_lookup(domain)
    display_whois_info(whois_info)
    
    await scan_potential_open_ports(domain)

if __name__ == "__main__":
    asyncio.run(main())
