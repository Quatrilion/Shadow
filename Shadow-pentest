import asyncio
import random
import string
import socket
import json
import requests
from aiohttp import ClientSession, ClientTimeout, TCPConnector
from prettytable import PrettyTable
from pyfiglet import Figlet
import logging
import itertools
from urllib.parse import urlparse
from concurrent.futures import ThreadPoolExecutor
import re
import ssl
import configparser
from time import time

class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

logging.basicConfig(filename='scan.log', level=logging.DEBUG)

def log_message(message):
    logging.info(message)

def print_header(title):
    f = Figlet(font='slant')
    header = f.renderText(title)
    print(f"\n{Colors.HEADER}{header}{Colors.ENDC}")

def validate_url(url):
    try:
        result = urlparse(url)
        return all([result.scheme, result.netloc])
    except ValueError:
        return False

def get_random_user_agent():
    USER_AGENTS = [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Firefox/90.0',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0',
        'Mozilla/5.0 (Linux; Android 10; SM-G973U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Mobile Safari/537.36',
        'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:90.0) Gecko/20100101 Firefox/90.0'
    ]
    return random.choice(USER_AGENTS)

async def fetch(url, session, method='GET', headers=None, params=None, timeout=10):
    timeout = ClientTimeout(total=timeout)
    params = params or {}  # Default to empty dict if None
    try:
        if method == 'GET':
            async with session.get(url, headers=headers, params=params, timeout=timeout) as response:
                if response.status == 200:
                    text = await response.text()
                    return response.status, text, response.headers
                else:
                    return response.status, None, None
        elif method == 'POST':
            async with session.post(url, headers=headers, json=params, timeout=timeout) as response:
                if response.status == 200:
                    text = await response.text()
                    return response.status, text, response.headers
                else:
                    return response.status, None, None
    except asyncio.TimeoutError:
        log_message(f"Request to {url} timed out.")
        print(f"{Colors.FAIL}Request to {url} timed out.{Colors.ENDC}")
        return None, None, None
    except aiohttp.ClientError as e:
        log_message(f"Client error: {e}")
        print(f"{Colors.FAIL}Client error occurred: {e}{Colors.ENDC}")
        return None, None, None
    except Exception as e:
        log_message(f"Unexpected error: {e}")
        print(f"{Colors.FAIL}Unexpected error occurred: {e}{Colors.ENDC}")
        return None, None, None

async def make_request(url, headers=None, params=None, timeout=10, method='GET'):
    async with ClientSession(connector=TCPConnector(ssl=False)) as session:
        return await fetch(url, session, method=method, headers=headers, params=params, timeout=timeout)

async def check_ssl_certificate(url):
    async with ClientSession(connector=TCPConnector(ssl=False)) as session:
        try:
            async with session.get(url, timeout=10) as response:
                if response.status == 200:
                    print(f"{Colors.OKGREEN}SSL/TLS sertifikası geçerli.{Colors.ENDC}")
                    # Get SSL certificate details
                    # Note: Use a library or extend this to fetch SSL cert details.
                else:
                    print(f"{Colors.FAIL}SSL/TLS sertifikası geçersiz.{Colors.ENDC}")
        except Exception as e:
            print(f"{Colors.FAIL}SSL/TLS sertifikası kontrolü başarısız: {e}{Colors.ENDC}")

async def check_security_headers(url, user_agent=None):
    headers = {'User-Agent': user_agent or get_random_user_agent()}
    status, _, response_headers = await make_request(url, headers=headers)
    if status is None:
        return

    security_headers = {
        'Content-Security-Policy': 'Web sayfası içeriğini korur.',
        'Strict-Transport-Security': 'HTTPS kullanımını zorunlu kılar.',
        'X-Content-Type-Options': 'MIME türlerinin doğru şekilde belirlenmesini sağlar.',
        'X-Frame-Options': 'Sayfanın başka bir sayfa içinde iframe olarak yüklenmesini engeller.',
        'X-XSS-Protection': 'Tarayıcı bazlı XSS korumasını etkinleştirir.',
        'Referrer-Policy': 'Referrer bilgilerini kontrol eder.',
        'Feature-Policy': 'Tarayıcı özelliklerini kontrol eder.',
        'Access-Control-Allow-Origin': 'CORS politikalarını belirler.',
        'Permissions-Policy': 'Tarayıcı izinlerini kontrol eder.'  # Yeni başlık eklendi
    }
    
    table = PrettyTable()
    table.field_names = ["Header", "Status", "Explanation"]
    
    for header, explanation in security_headers.items():
        status = response_headers.get(header, "Not Found")
        color = Colors.OKGREEN if status != "Not Found" else Colors.FAIL
        table.add_row([header, f"{color}{status}{Colors.ENDC}", explanation])
    
    print_header("Güvenlik Başlıkları Kontrolü")
    print(table)

async def perform_tests_for_payloads(url, payloads, test_name, param_name):
    results = []
    payloads = payloads or []  # Default to empty list if None
    
    async with ClientSession(connector=TCPConnector(ssl=False)) as session:
        for payload in payloads:
            test_url = f"{url}?{param_name}={payload}"
            headers = {'User-Agent': get_random_user_agent()}
            status, text, _ = await fetch(test_url, session, headers=headers)
            
            # Check if text is None before calling lower()
            if status and text and ("error" in text.lower() or "mysql" in text.lower()):
                results.append(test_url)
    
    print_header(test_name)
    if results:
        table = PrettyTable()
        table.field_names = [f"Potential {test_name}"]
        for result in results:
            table.add_row([f"{Colors.FAIL}{result}{Colors.ENDC}"])
            log_message(f"Potential {test_name}: {result}")
        print(table)
    else:
        print(f"{Colors.OKGREEN}Açık bulunamadı.{Colors.ENDC}")

async def test_sql_injection(url):
    payloads = ["' OR '1'='1", '" OR "1"="1', "' OR 1=1 --"]
    await perform_tests_for_payloads(url, payloads, "SQL Enjeksiyonu Testi", "search")

async def test_xss(url):
    payloads = ["<script>alert('XSS')</script>", "<img src='x' onerror='alert(1)'>"]
    await perform_tests_for_payloads(url, payloads, "XSS Testi", "search")

async def test_command_injection(url):
    payloads = ["; ls", "| ls", "`ls`"]
    await perform_tests_for_payloads(url, payloads, "Komut Enjeksiyonu Testi", "cmd")

async def test_ssrf(url):
    payloads = ["http://localhost:8080", "http://169.254.169.254/latest/meta-data/"]
    await perform_tests_for_payloads(url, payloads, "SSRF Testi", "target")

async def test_dns_rebinding(url):
    payloads = ["http://example.com", "http://localhost"]
    await perform_tests_for_payloads(url, payloads, "DNS Rebinding Testi", "target")

async def test_rate_limiting(url, user_agent=None, limit=10):
    headers = {'User-Agent': user_agent or get_random_user_agent()}
    async with ClientSession(connector=TCPConnector(ssl=False)) as session:
        for i in range(limit):
            status, _, _ = await fetch(url, session, headers=headers)
            if status == 429:
                print(f"{Colors.WARNING}Rate limiting detected.{Colors.ENDC}")
                break
        else:
        	print(f"{Colors.OKGREEN}No rate limiting detected.{Colors.ENDC}")

async def scan_ports(host, ports):
    async def scan_port(port):
        try:
            conn = asyncio.open_connection(host, port)
            reader, writer = await asyncio.wait_for(conn, timeout=1)
            writer.close()
            await writer.wait_closed()
            return port, True
        except (asyncio.TimeoutError, ConnectionRefusedError):
            return port, False

    results = await asyncio.gather(*(scan_port(port) for port in ports))
    open_ports = [port for port, is_open in results if is_open]
    closed_ports = [port for port, is_open in results if not is_open]
    
    print_header("Port Scan Sonuçları")
    if open_ports:
        print(f"{Colors.OKGREEN}Açık portlar: {', '.join(map(str, open_ports))}{Colors.ENDC}")
    if closed_ports:
        print(f"{Colors.FAIL}Kapalı portlar: {', '.join(map(str, closed_ports))}{Colors.ENDC}")

async def main():
    print_header("Shadow")
    url = input("Test edilecek URL'yi girin: ")
    
    if not validate_url(url):
        print(f"{Colors.FAIL}Geçersiz URL.{Colors.ENDC}")
        return
    
    await check_ssl_certificate(url)
    await check_security_headers(url)
    
    await test_sql_injection(url)
    await test_xss(url)
    await test_command_injection(url)
    await test_ssrf(url)
    await test_dns_rebinding(url)
    
    await test_rate_limiting(url)
    
    parsed_url = urlparse(url)
    host = parsed_url.netloc
    ports = [80, 443, 21, 22, 3306, 6379]
    await scan_ports(host, ports)

if __name__ == "__main__":
    asyncio.run(main())
